Status: hypothesis
Confidence: medium

# MVRS reproducibility criterion (Rust sketch): strict/practical + Wilson LB + min_trials always

Контекст: это не внедрение в текущий код репозитория (здесь сейчас Python-скелет Phase I), а **заметка-эскиз** для будущего выделенного Rust-крейта/модуля, который будет реализовывать критерий воспроизводимости MVRS как исполнимый контракт.

Цель заметки:
- зафиксировать “абсолютно финальную” структуру модулей и тестов (как предлагалось ранее),
- устранить мелкие замечания, с которыми согласен: **константы**, **margin rule как отдельная функция**, **док/доктест**, минимальная интроспекция,
- не притворяться, что это уже код этого репо: это **reference sketch**.

## 1) src/repro/stats_utils.rs (плоская структура + проверка alpha)

```rust
// src/repro/stats_utils.rs
// Внутренние статистические утилиты

const EPS_ALPHA: f64 = 1e-10;

/// Проверяет, поддерживается ли alpha.
/// Поддерживаем только {0.10, 0.05, 0.01}.
pub(crate) fn is_supported_alpha(alpha: f64) -> bool {
    (alpha - 0.10).abs() < EPS_ALPHA ||
    (alpha - 0.05).abs() < EPS_ALPHA ||
    (alpha - 0.01).abs() < EPS_ALPHA
}

/// Wilson one-sided lower bound (аппроксимация).
/// Требует alpha ∈ {0.10, 0.05, 0.01}; предполагается, что alpha уже провалидирован.
pub(crate) fn wilson_one_sided_lower(k: usize, n: usize, alpha: f64) -> f64 {
    if n == 0 { return 0.0; } // защитная оговорка

    let p_hat = k as f64 / n as f64;

    if p_hat <= 0.0 { return 0.0; }
    if p_hat >= 1.0 { return 1.0; }

    // z_{1-α} для one-sided (только поддерживаемые значения)
    let z = match alpha {
        a if (a - 0.10).abs() < EPS_ALPHA => 1.28155, // 90% one-sided
        a if (a - 0.05).abs() < EPS_ALPHA => 1.64485, // 95% one-sided
        a if (a - 0.01).abs() < EPS_ALPHA => 2.32635, // 99% one-sided
        _ => unreachable!("alpha must be validated by is_supported_alpha()"),
    };

    let nf = n as f64;
    let denominator = 1.0 + z * z / nf;
    let center = p_hat + z * z / (2.0 * nf);
    let spread = z * (p_hat * (1.0 - p_hat) / nf + z * z / (4.0 * nf * nf)).sqrt();

    ((center - spread) / denominator).max(0.0)
}
2) src/repro/mvrs_criterion.rs (константы + margin rule + min_trials always)
Замечание “почему Ok(false) без причины” — валидно, но это уже изменение API (нужен report/diagnostics). В этом эскизе я оставляю Result<bool, CriterionError> как контракт, а диагностику предлагаю отдельным методом analyze() в будущем (не смешивать критерий и телеметрию на первом шаге).
Копировать код
Rust
// src/repro/mvrs_criterion.rs (фрагменты)
use crate::repro::stats_utils;

const MARGIN_N_LT_30: usize = 30;
const MARGIN_N_LT_100: usize = 100;

const MARGIN_FOR_N_LT_30: f64 = 0.10;
const MARGIN_FOR_N_LT_100: f64 = 0.05;
const MARGIN_FOR_N_GE_100: f64 = 0.02;

fn practical_margin(n: usize) -> f64 {
    if n < MARGIN_N_LT_30 {
        MARGIN_FOR_N_LT_30
    } else if n < MARGIN_N_LT_100 {
        MARGIN_FOR_N_LT_100
    } else {
        MARGIN_FOR_N_GE_100
    }
}

impl MvrsMode {
    fn wilson_one_sided_lower(&self, k: usize, n: usize, alpha: f64) -> Result<f64, CriterionError> {
        if !stats_utils::is_supported_alpha(alpha) {
            return Err(CriterionError::UnsupportedAlpha { alpha });
        }
        Ok(stats_utils::wilson_one_sided_lower(k, n, alpha))
    }

    /// Строгий критерий: Clopper-Pearson exact lower bound.
    /// КРИТИЧЕСКОЕ: min_trials проверяется ВСЕГДА.
    fn strict_criterion(
        &self,
        k: usize,
        n: usize,
        target: f64,
        alpha: f64,
        min_trials: usize,
    ) -> Result<bool, CriterionError> {
        if n < min_trials {
            return Err(CriterionError::InsufficientTrials { actual: n, min_required: min_trials });
        }
        let lower_bound = self.clopper_pearson_lower(k, n, alpha)?;
        Ok(lower_bound >= target)
    }

    /// Practical criterion: point estimate + optional Wilson LB, with “margin rule”.
    fn practical_criterion(
        &self,
        k: usize,
        n: usize,
        target: f64,
        alpha: f64,
        min_trials: usize,
        require_confidence: bool,
    ) -> Result<bool, CriterionError> {
        if n < min_trials {
            return Err(CriterionError::InsufficientTrials { actual: n, min_required: min_trials });
        }

        let p_hat = k as f64 / n as f64;
        if p_hat < target { return Ok(false); }

        if !require_confidence {
            return Ok(true);
        }

        let margin = practical_margin(n);
        let wilson_lb = self.wilson_one_sided_lower(k, n, alpha)?;
        Ok(wilson_lb >= target - margin)
    }
}
3) Документация + doctest (как минимум — для public API)
Копировать код
Rust
/// Determines if results are reproducible according to MVRS criteria.
///
/// # Arguments
/// * `successes` - number of successful trials (k)
/// * `total` - total trials (n)
///
/// # Errors
/// Returns `CriterionError::InsufficientTrials` if `total < min_trials()`.
///
/// # Examples
/// ```
/// use atlas_mvrs::repro::MvrsMode;
/// let mode = MvrsMode::practical();
/// assert!(mode.is_reproducible(20, 20).unwrap());
/// ```
pub fn is_reproducible(&self, successes: usize, total: usize) -> Result<bool, CriterionError> {
    // ...
}
4) Тесты (эскиз состава)
tests/ci_smoke_test.rs: минимальные тесты, которые проходят всегда.
tests/compatibility_test.rs: проверка семантики min_trials и practical-логики.
Feature-gated тесты для строгого режима при k < n (требует stats/beta).
Ключевой инвариант заметки:
min_trials — никогда не превращается в Ok(false): это всегда Err(InsufficientTrials).
